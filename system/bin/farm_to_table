#!/bin/bash

# farm_to_table
# Matt Allbright
# This script will automatically pull data from Hermes for studies and then sort
# individual files into the proper study directory. It is based on ideas from
# previous "convertit"-type scripts used in the lab.

#Functions

# Function necessary to figure out the intracacies of each study
# Why they were set up in completely different ways, and in completely different
# structures, is beyond me
getInfo() {
  if [ $study = "tbimodel" ] || [ $study = "TBIMODEL" ]; then
    longitudinalBool=0
    # Forcing new prefix to TBIMODEL_000 standard
    studyPrefix="TM"
    boldValues=("resting")
    magPhaseBool=1
    dtiBool=1
  elif [ $study = "BLHC" ]; then
    longitudinalBool=0
    studyPrefix="BLHC"
    boldValues=("resting" "MSIT" "NBACK")
    magPhaseBool=0
    dtiBool=0
    echo "$study is not set up properly with this system."
    echo "Contact a system administrator."
    exit 1
  elif [ $study = "BL2" ]; then
    longitudinalBool=1
    studyPrefix="BL2_"
    boldValues=("resting" "MSIT" "NBACK")
    magPhaseBool=0
    dtiBool=1
  elif [ $study = "blt" ]; then
    longitudinalBool=1
    studyPrefix="BL"
    boldValues=("resting" "MSIT" "NBACK")
    magPhaseBool=0
    dtiBool=0
    echo "$study is not set up properly with this system."
    echo "Contact a system administrator."
    exit 1
  elif [ $study = "BLPTSD" ]; then
    longitudinalBool=1
    studyPrefix="BLPTSD_"
    boldValues=("resting" "anticipation" "BMAT_fear" "BMAT_happy" "dot_probe" "fear_conditioning")
    magPhaseBool=0
    dtiBool=1
  elif [ $study = "EWM" ]; then
    longitudinalBool=0
    studyPrefix="EWM_"
    boldValues=("resting" "Faces" "IAPS")
    magPhaseBool=0
    dtiBool=0
  elif [ $study = "EIT" ]; then
    longitudinalBool=0
    studyPrefix="EIT_"
    boldValues=()
    magPhaseBool=0
    dtiBool=0
  elif [ $study = "emot" ]; then
    longitudinalBool=0
    studyPrefix="emot"
    boldValues=("anger" "EmotDist" "faceint" "fear" "food" "happy" "memsupp" "sceneint" "trust" "resting")
    magPhaseBool=0
    dtiBool=0
    echo "$study is not set up properly with this system."
    echo "Contact a system administrator."
    exit 1
  elif [ $study = "ICBT" ]; then
    longitudinalBool=1
    studyPrefix="ICBT"
    boldValues=("EIT")
    magPhaseBool=0
    dtiBool=0
    echo "$study is not set up properly with this system."
    echo "Contact a system administrator."
    exit 1
  elif [ $study = "Cogr" ]; then
    longitudinalBool=0
    studyPrefix="CR"
    boldValues=("resting" "MSIT" "NBACK")
    magPhaseBool=0
    dtiBool=0
  elif [ $study = "Cogr2" ]; then
    longitudinalBool=0
    studyPrefix="CRG_"
    boldValues=("resting" "MSIT" "NBACK")
    magPhaseBool=0
    dtiBool=0
  else
    echo "Study not found: $study"
    exit 1
  fi
}

# Just grabs data from Hermes
HermesFetch(){
  # Bunch of error checking before forcing a fetch
  if [ ! -d /Hermes ]; then
    echo "Hermes directory doesn't exist!"
    exit 1
  elif [ -z "$(ls -A /Hermes)" ]; then
    echo "Hermes isn't mounted properly!"
    exit 1
  fi
  if [ ! -d $studyDir ]; then
    echo "$study directory doesn't exist!"
    exit 1
  elif [ -z "$(ls -A $studyDir)" ]; then
    echo "$study isn't mounted properly!"
    exit 1
  fi

  if [ ! -d $particRawDir ]; then
    # Fetch data from RAW for $partic
    echo "Locating data for $partic..."
    # Strip partic to just the numbers
    particNumber=`echo $partic | grep -Eo '[0-9][0-9][0-9]'`
    # Find folder where number pattern is present
    rawCheckString=`find /Hermes/"$study"_scans -maxdepth 2 -iname "*$particNumber*" -print | sort | tail -1`
    if [[ ! -z "${rawCheckString// }" ]]; then
      mkdir -p $particRawDir
      osirixDir=`find /Hermes/"$study"_scans -maxdepth 2 -iname "*$particNumber*" -print | sort | tail -1` #| sed 's/.*\///'
      echo "Copying data from shared mount..."
      cp -r "$osirixDir/." $particRawDir/
      dataNotFound=0
    else
      echo "No data found for $partic. Make sure Osirix data is anonymized and organized."
      dataNotFound=1
    fi
  else
    if [ $bypassOverwrite -eq 0 ]; then
      echo "The RAW directory already exists for this user. Would you like to copy"
      echo "anyway? Typically RAW_data can be overwritten without consequence."
      read rawResponse
    fi
    if [[ "$rawResponse" =~ ^([yY][eE][sS]|[yY])+$ ]]; then
      # Fetch data from RAW for $partic
      echo "Locating data for $partic..."
      # Strip partic to just the numbers
      particNumber=`echo $partic | grep -Eo '[0-9][0-9][0-9]'`
      # Find folder where number pattern is present
      rawCheckString2=`find /Hermes/"$study"_scans -maxdepth 2 -iname "*$particNumber*" -print | sort | tail -1`
      if [[ ! -z "${rawCheckString2// }" ]]; then
        osirixDir=`find /Hermes/"$study"_scans -maxdepth 2 -iname "*$particNumber*" -print | sort | tail -1` #| sed 's/.*\///'
        echo "Copying data from shared mount..."
        cp -r "$osirixDir/." $particRawDir/
        dataNotFound=0
      else
        echo "No data found for $partic. Make sure Osirix data is anonymized and organized."
        dataNotFound=1
      fi
      if [ $overwriteTriggerCount -eq 0 ]; then
        overwriteTriggerCount=$((overwriteTriggerCount + 1))
        echo "It appears that there are a number of overwritable RAW directories which you have chosen."
        echo "Would you like to overwrite all future RAW directories and bypass the prompt?"
        read overwriteResponse
        if [[ "$rawResponse" =~ ^([yY][eE][sS]|[yY])+$ ]]; then
          bypassOverwrite=1
        fi
      fi
      overwriteTriggerCount=$((overwriteTriggerCount + 1))
    else
      echo "Data will not be modified. Continuing with structure..."
      dataNotFound=0
    fi
  fi
}

overwriteTriggerCount=0
overwriteIndivCount=0
overwriteLongCount=0
bypassOverwrite=0
bypassIndivOverwrite=0

# Start program

echo "Welcome to Farm to Table."
echo "Farm to Table takes images and data from the machine Hermes and sorts"
echo "these files into a structured system for use with FSL, FreeSurfer, and"
echo "other real cool software."

echo "First, we need a study."
# New menu variables
studySelectArr=(/data/* "New study")

# Create menu
select studyDir in "${studySelectArr[@]}"; do
  case $studyDir in
    "New study")
      echo "Creating new study..."
      echo "This system is not implemented yet."
      newStudyBool=1
      break
      ;;
    *)
      echo "Selected $studyDir"
      newStudyBool=0
      break
      ;;
  esac
done

if [ $newStudyBool -eq 1 ]; then
  echo "What is the name of the study you would like to create? (e.g. EIT, tbimodel)"
  echo "Please refrain from using spaces or non-letter characters."
  read study
  studyDir="/data/$study"
  if [ -d /data/$study ]; then
    echo "Study already exists!"
    exit 1
  else
    echo "New study system not implemented"
    exit 1
  fi
fi

study=${studyDir#*/data/}
getInfo $study

# Init array
particArr=()

echo "What are the number(s) of the participants you would like to process?"
echo "Separate each with a space (e.g. 005 006 016 185). You can also type 'all'"
echo "to run through all subjects."
read particNums # Pull the numbers as delimited variables
particReadArr=($particNums) # Shove said numbers into an array
if [ $particNums = "all" ]; then
  particNumArr=( $(ls /Hermes/"$study"_scans/ | grep -Eo '[0-9][0-9][0-9]') )
else
  particNumArr=($particNums)
fi

for partic in ${particNumArr[*]}; do
  particNum=`echo $partic | grep -Eo '[0-9][0-9][0-9]'`
  if [ "$partic" = x"$partic" ]; then
    echo "Not a valid id. Skipping.."
  else
    particArr+=("$studyPrefix$particNum") # Clean up the numbers array by adding a prefix (eg 102 becomes TM_102)
    echo "Found $partic..."
  fi
done

IFS=$'\n'

# Get data from Hermes for the participant(s)
for partic in ${particArr[*]}; do
  echo "Starting download for $partic"
  particRawDir="$studyDir/RAW_data/$partic"
  echo "ParticRawDir is $particRawDir"
  HermesFetch $partic

  if [ $dataNotFound -eq 1 ]; then
    echo "-----------------------------------------------"
    echo "No Osirix data found for $partic. Moving on..."
    echo "-----------------------------------------------"
  else
    # Create directory structure
    particDir=$studyDir/indiv_analysis/$partic
    echo "ParticDir is $particDir"
    if [ ! -d $particDir ]; then
      echo "Creating directory for $partic"
      dirAlreadyExists=0
      mkdir -p $particDir
    else
      echo "Directory detected."
      dirAlreadyExists=1
    fi

    # Longitudinal structuring
    if [ $longitudinalBool -eq 1 ]; then
      echo "Logitudinal study detected."
      # Check baseline directory existence
      baseCheckString=`find $particRawDir -maxdepth 2 -iname "*_BV" -print | sort | tail -1`
      if [[ ! -z "${baseCheckString// }" ]]; then
        echo "Baseline detected."
        baselineRawDir=`find $particRawDir -maxdepth 2 -iname "*_BV" -print | sort | tail -1`
        echo "BaselineRawDir is $baselineRawDir"
        if [ $dirAlreadyExists -eq 1 ]; then
          if [ $bypassIndivOverwrite -eq 0 ]; then
            echo "The indiv_analysis directory already exists."
            echo "Would you like to copy and possibly overwrite your Baseline indiv_analysis images?"
            read overwriteBaseline
          elif [ $bypassIndivOverwrite -eq 1 ]; then
            baselineBool=1
          fi
          if [[ "$overwriteBaseline" =~ ^([yY][eE][sS]|[yY])+$ ]]; then
            baselineBool=1
            if [ $overwriteIndivCount -eq 0 ]; then
              overwriteIndivCount=$((overwriteIndivCount + 1))
              echo "It appears that there are a number of overwritable indiv_analysis directories which you have chosen."
              echo "Would you like to overwrite all future indiv_analysis directories and bypass the prompt?"
              read overwriteIndivResponse
              if [[ "$overwriteIndivResponse" =~ ^([yY][eE][sS]|[yY])+$ ]]; then
                bypassIndivOverwrite=1
              fi
            fi
            overwriteIndivCount=$((overwriteIndivCount + 1))
          fi
        else
          baselineBool=1
        fi
      else
        echo "Baseline not detected."
        baselineBool=0
      fi
      # Check post-treament directory existence
      postCheckString=`find $particRawDir -maxdepth 2 -iname "*_PTX" -print | sort | tail -1`
      if [[ ! -z "${postCheckString// }" ]]; then
        echo "PostTX detected."
        postTXRawDir=`find $particRawDir -maxdepth 2 -iname "*_PTX" -print | sort | tail -1`
        echo "PostTXRawDir is $postTXRawDir"
        if [ $dirAlreadyExists -eq 1 ]; then
          if [ $bypassIndivOverwrite -eq 0 ]; then
            echo "The indiv_analysis directory already exists."
            echo "Would you like to copy and possibly overwrite your PostTX indiv_analysis images?"
            read overwritePostTX
          elif [ $bypassIndivOverwrite -eq 1 ]; then
            postTXBool=1
          fi
          if [[ "$overwritePostTX" =~ ^([yY][eE][sS]|[yY])+$ ]]; then
            postTXBool=1
            if [ $overwriteIndivCount -eq 0 ]; then
              overwriteIndivCount=$((overwriteIndivCount + 1))
              echo "It appears that there are a number of overwritable indiv_analysis directories which you have chosen."
              echo "Would you like to overwrite all future indiv_analysis directories and bypass the prompt?"
              read overwriteIndivResponse
              if [[ "$overwriteIndivResponse" =~ ^([yY][eE][sS]|[yY])+$ ]]; then
                bypassIndivOverwrite=1
              fi
            fi
            overwriteIndivCount=$((overwriteIndivCount + 1))
          fi
        else
          postTXBool=1
        fi
      else
        echo "PostTX not detected."
        postTXBool=0
      fi

      if [ $baselineBool -eq 1 ]; then
        echo "Running for Baseline."
      elif [ $baselineBool -eq 0 ]; then
        echo "Not running for Baseline"
      else
        echo "Non-logitudinal detected"
      fi

      if [ $postTXBool -eq 1 ]; then
        echo "Running for PostTX."
      elif [ $postTXBool -eq 0 ]; then
        echo "Not running for PostTX"
      else
        echo "Non-logitudinal detected"
      fi

      # Baseline Anatomical
      if [ $baselineBool -eq 1 ]; then
        anatDirArr=($(find $baselineRawDir -maxdepth 2 -iname "T1_MPRAGE_1MM*" -print | sort))
        anatNum=1
        if [ ! -d $particDir/anatomicals/Baseline ]; then
          mkdir -p $particDir/anatomicals/Baseline
        fi
        for anatomical in ${anatDirArr[@]}; do
          echo "Running dcm2nii for Anatomical $anatNum located in $anatomical"
          dcm2niix -f "$partic"_anatomical_$anatNum -o $particDir/anatomicals/Baseline "${anatomical}"
          anatNum=$((anatNum+1))
        done
      fi

      # PostTX Anatomical
      if [ $postTXBool -eq 1 ]; then
        anatDirArr=($(find $postTXRawDir -maxdepth 2 -iname "T1_MPRAGE_1MM*" -print | sort))
        anatNum=1
        if [ ! -d $particDir/anatomicals/PostTX ]; then
          mkdir -p $particDir/anatomicals/PostTX
        fi
        for anatomical in ${anatDirArr[@]}; do
          echo "Running dcm2nii for Anatomical $anatNum located in $anatomical"
          dcm2niix -f "$partic"_anatomical_$anatNum -o $particDir/anatomicals/PostTX "${anatomical}"
          anatNum=$((anatNum+1))
        done
      fi

      # Baseline T2
      if [ $baselineBool -eq 1 ]; then
        anatBDirArr=($(find $baselineRawDir -maxdepth 2 -iname "*FLAIR*" -print | sort))
        anatNumB=1
        if [ ! -d $particDir/anatomicals/Baseline ]; then
          mkdir -p $particDir/anatomicals/Baseline
        fi
        for anatomical in ${anatBDirArr[@]}; do
          echo "Running dcm2nii for Anatomical $anatNum located in $anatomical"
          dcm2niix -f "$partic"_t2_$anatNumB -o $particDir/anatomicals/Baseline "${anatomical}"
          anatNumB=$((anatNumB+1))
        done
      fi

      # PostTX T2
      if [ $postTXBool -eq 1 ]; then
        anatBDirArr=($(find $postTXRawDir -maxdepth 2 -iname "*FLAIR*" -print | sort))
        anatNumB=1
        if [ ! -d $particDir/anatomicals/PostTX ]; then
          mkdir -p $particDir/anatomicals/PostTX
        fi
        for anatomical in ${anatBDirArr[@]}; do
          echo "Running dcm2nii for Anatomical $anatNum2 located in $anatomical"
          dcm2niix -f "$partic"_t2_$anatNumB -o $particDir/anatomicals/PostTX "${anatomical}"
          anatNumB=$((anatNumB+1))
        done
      fi

      # Checks if bold array is empty
      if [ ${#boldValues[@]} -eq 0 ]; then
        echo "No BOLD tasks for $partic"
      else
        echo "Running BOLD for $partic"
        # Run bold sorting
        for bold_type in ${boldValues[*]}; do
          # Checks postTX bool
          echo "Running $bold_type"
          if [ $baselineBool -eq 1 ]; then
            # If task directory exists run dcm2niix on it
            baseCheckString2=`find $baselineRawDir -maxdepth 2 -iname "*${bold_type}*" -print | sort | tail -1`
            if [[ ! -z "${baseCheckString2// }" ]]; then
              echo "Check passed..."
              # Makes directory if it doesn't exist
              if [ ! -d $particDir/bold/${bold_type}/Baseline ]; then
                mkdir -p $particDir/bold/${bold_type}/Baseline
              fi
              # Takes latest directory with bold
              boldDir=`find $baselineRawDir -maxdepth 2 -iname "*${bold_type}*" -print | sort | tail -1`
              dcm2niix -f "$partic"_${bold_type} -o $particDir/bold/${bold_type}/Baseline "$boldDir"
            else
              echo "No data for $bold_type in baseline $partic directory."
            fi
          fi
          # Checks postTX bool
          if [ $postTXBool -eq 1 ]; then
            # If task directory exists run dcm2niix on it
            postCheckString2=`find $baselineRawDir -maxdepth 2 -iname "*${bold_type}*" -print | sort | tail -1`
            if [[ ! -z "${postCheckString2// }" ]]; then
              # Makes directory if it doesn't exist
              if [ ! -d $particDir/bold/${bold_type}/PostTX ]; then
                mkdir -p $particDir/bold/${bold_type}/PostTX
              fi
              boldDir=`find $baselineRawDir -maxdepth 2 -iname "*${bold_type}*" -print | sort | tail -1`
              dcm2niix -f "$partic"_${bold_type} -o $particDir/bold/${bold_type}/PostTX "$boldDir"
            else
              echo "No data for $bold_type in post-treatment $partic directory."
            fi
          fi
        done
      fi

      # Baseline fieldmaps
      if [ $magPhaseBool -eq 1 ]; then
        # Running for Mag (note the sort -r)
        echo "Beginning Magnitude-Phase fieldmap conversion..."
        # Baseline
        if [ $baselineBool -eq 1 ]; then
          magBaselineDir=`find $baselineRawDir -maxdepth 2 -iname "*field*" -print | sort -r | tail -1`
          if [ ! -d $particDir/fieldmaps/Baseline ]; then
            mkdir -p $particDir/fieldmaps/Baseline
          fi
          echo "Running dcm2nii for Mag fieldmaps"
          dcm2niix -f "$partic"_Mag -o $particDir/fieldmaps/Baseline "$magBaselineDir"
        fi
        # PostTX
        if [ $postTXBool -eq 1 ]; then
          magPostTXDir=`find $postTXRawDir -maxdepth 2 -iname "*field*" -print | sort -r | tail -1`
          if [ ! -d $particDir/fieldmaps/PostTX ]; then
            mkdir -p $particDir/fieldmaps/PostTX
          fi
          echo "Running dcm2nii for Mag fieldmaps"
          dcm2niix -f "$partic"_Mag -o $particDir/fieldmaps/PostTX "$magPostTXDir"
        fi

        # Running same system for Phase
        # Baseline
        if [ $baselineBool -eq 1 ]; then
          phaseBaselineDir=`find $baselineRawDir -maxdepth 2 -iname "*field*" -print | sort | tail -1`
          echo "Running dcm2nii for Mag fieldmaps"
          dcm2niix -f "$partic"_Phase -o $particDir/fieldmaps/Baseline "$phaseBaselineDir"
        fi
        # PostTX
        if [ $postTXBool -eq 1 ]; then
          phasePostTXDir=`find $postTXRawDir -maxdepth 2 -iname "*field*" -print | sort | tail -1`
          echo "Running dcm2nii for Mag fieldmaps"
          dcm2niix -f "$partic"_Phase -o $particDir/fieldmaps/PostTX "$phasePostTXDir"
        fi
      else
        echo "No Magnitude of Phase fieldmaps found for $partic"
      fi
      if [ $dtiBool -eq 1 ]; then
        echo "Beginning DTI conversion..."
        # Baseline DTI
        if [ $baselineBool -eq 1 ]; then
          baseCheckString3=`find $baselineRawDir -maxdepth 2 -iname "*dti*" -print | sort | tail -1`
          if [[ ! -z "${baseCheckString3// }" ]]; then
            dtiAPBaselineDir=`find $baselineRawDir -maxdepth 2 -iname "*dti*" -print | sort -r | tail -1`
            if [ ! -d $particDir/dti/Baseline ]; then
              mkdir -p $particDir/dti/Baseline
            fi
            echo "Running dcm2nii for DTI A -> P"
            dcm2niix -f "$partic"_A2P -o $particDir/dti/Baseline "$dtiAPBaselineDir"

            # Running same system for DTI P -> A
            dtiPABaselineDir=`find $baselineRawDir -maxdepth 2 -iname "*P-?A*" -print | sort | tail -1`
            if [ "$dtiPABaselineDir" == "x$dtiPABaselineDir" ]; then
              echo "P->A file not found, searching P__A"
              dtiPABaselineDir=`find $postTXRawDir -maxdepth 2 -iname "*P_?A*" -print | sort | tail -1`
              if [ "$dtiPABaselineDir" == "x$dtiPABaselineDir" ]; then
                echo "P__A file not found, searching bzero identifier"
                dtiPABaselineDir=`find $baselineRawDir -maxdepth 2 -iname "*bzero*" -print | sort | tail -1`
              fi
            fi
            if [ "$dtiAPBaselineDir" == "$dtiPABaselineDir" ]; then
              echo "A -> P and P -> A mismatch for $partic, verify folders exist."
            else
              echo "Running dcm2nii for DTI P -> A"
              dcm2niix -f "$partic"_P2A -o $particDir/dti/Baseline "$dtiPABaselineDir"
            fi
            bval=`find $particDir/dti/Baseline -maxdepth 2 -iname "*bval*" -print | sort | tail -1`
            bvec=`find $particDir/dti/Baseline -maxdepth 2 -iname "*bvec*" -print | sort | tail -1`
            mv $bval $particDir/dti/Baseline/bvals
            mv $bvec $particDir/dti/Baseline/bvecs
          else
            echo "No DTI images found for $partic Baseline"
          fi
        fi
        # PostTX DTI A -> P
        if [ $postTXBool -eq 1 ]; then
          postCheckString3=`find $baselineRawDir -maxdepth 2 -iname "*dti*" -print | sort | tail -1`
          if [[ ! -z "${postCheckString3// }" ]]; then
            dtiAPPostTXDir=`find $postTXRawDir -maxdepth 2 -iname "*dti*" -print | sort -r | tail -1`
            if [ ! -d $particDir/dti/PostTX ]; then
              mkdir -p $particDir/dti/PostTX
            fi
            echo "Running dcm2nii for DTI A -> P"
            dcm2niix -f "$partic"_A2P -o $particDir/dti/PostTX "$dtiAPPostTXDir"

            # Running same system for DTI P -> A
            dtiPAPostTXDir=`find $postTXRawDir -maxdepth 2 -iname "*P-?A*" -print | sort | tail -1`
            if [ "$dtiPAPostTXDir" == "x$dtiPAPostTXDir" ]; then
              echo "P->A file not found, searching P__A"
              dtiPAPostTXDir=`find $postTXRawDir -maxdepth 2 -iname "*P_?A*" -print | sort | tail -1`
              if [ "$dtiPAPostTXDir" == "x$dtiPAPostTXDir" ]; then
                echo "P__A file not found, searching bzero identifier"
                dtiPAPostTXDir=`find $postTXRawDir -maxdepth 2 -iname "*bzero*" -print | sort | tail -1`
              fi
            fi
            if [ "$dtiAPPostTXDir" == "$dtiPAPostTXDir" ]; then
              echo "A -> P and P -> A mismatch for $partic, verify folders exist."
            else
              echo "Running dcm2nii for DTI P -> A"
              dcm2niix -f "$partic"_P2A -o $particDir/dti/PostTX "$dtiPAPostTXDir"
            fi
            bval=`find $particDir/dti/PostTX -maxdepth 2 -iname "*bval*" -print | sort | tail -1`
            bvec=`find $particDir/dti/PostTX -maxdepth 2 -iname "*bvec*" -print | sort | tail -1`
            mv $bval $particDir/dti/PostTX/bvals
            mv $bvec $particDir/dti/PostTX/bvecs
          else
            echo "No DTI images found for $partic PostTX"
          fi
        fi
      else
        echo "DTI images are not taken for $study"
      fi
      echo "Finished transfer and conversion for $partic"
    # Non-logitudinal structuring
    else
      echo "Non-logitudinal study detected."
      if [ $dirAlreadyExists -eq 1 ]; then
        if [ $bypassIndivOverwrite -eq 0 ]; then
          echo "The indiv_analysis directory already exists."
          echo "Would you like to copy and possibly overwrite your indiv_analysis images?"
          read overwritePartic
        fi
        if [[ "$overwritePartic" =~ ^([yY][eE][sS]|[yY])+$ ]]; then
          echo "Continuing with copy..."
          if [ $overwriteLongCount = 0 ]; then
            overwriteLongCount=$((overwriteLongCount + 1))
            echo "It appears that there are a number of overwritable indiv_analysis directories which you have chosen."
            echo "Would you like to overwrite all future indiv_analysis directories and bypass the prompt?"
            read overwriteIndivResponse
            if [[ "$overwriteIndivResponse" =~ ^([yY][eE][sS]|[yY])+$ ]]; then
              bypassIndivOverwrite=1
            fi
          fi
          overwriteIndivCount=$((overwriteIndivCount + 1))
        else
          particBool=0
        fi
      fi
      #T1
      echo "Running dcm2nii for T1 Anatomicals"
      anatDirArr=($(find $particRawDir -maxdepth 2 -iname "T1_MPRAGE_1MM*" -print | sort))
      anatNum=1
      if [ ! -d $particDir/anatomicals ]; then
        mkdir -p $particDir/anatomicals
      fi
      for anatomical in ${anatDirArr[@]}; do
        echo "Running dcm2nii for Anatomical $anatNum located in $anatomical"
        dcm2niix -f "$partic"_anatomical_$anatNum -o $particDir/anatomicals "${anatomical}"
        anatNum=$((anatNum+1))
      done

      #T2

      echo "Running dcm2nii for T2 Anatomicals"
      anatBDirArr=($(find $particRawDir -maxdepth 2 -iname "*FLAIR*" -print | sort))
      anatNumB=1
      if [ ! -d $particDir/anatomicals ]; then
        mkdir -p $particDir/anatomicals
      fi
      for anatomical in ${anatBDirArr[@]}; do
        echo "Running dcm2nii for Anatomical $anatNumB located in $anatomical"
        dcm2niix -f "$partic"_t2_$anatNumB -o $particDir/anatomicals "${anatomical}"
        anatNumB=$((anatNumB+1))
      done

      if [ ${#boldValues[@]} -eq 0 ]; then
        echo "No BOLD values for $partic"
      else
        echo "Running BOLD for $partic"
        for bold_type in ${boldValues[*]}; do
          # If task directory exists run dcm2niix on it
          boldCheckString=`find $particRawDir -maxdepth 2 -iname "*${bold_type}*" -print | sort | tail -1`
          if [[ ! -z "${boldCheckString// }" ]]; then
            # Makes directory if it doesn't exist
            if [ ! -d $particDir/bold/${bold_type} ]; then
              mkdir -p $particDir/bold/${bold_type}
            fi
            boldDir=`find $particRawDir -maxdepth 2 -iname "*${bold_type}*" -print | sort | tail -1`
            dcm2niix -f "$partic"_${bold_type} -o $particDir/bold/${bold_type} "$boldDir"
          else
            echo "No data for $bold_type in $partic directory."
          fi
        done
      fi

      if [ $magPhaseBool -eq 1 ]; then
        fieldCheckString=`find $particRawDir -maxdepth 2 -iname "*field*" -print | sort | tail -1`
        if [[ ! -z "${fieldCheckString// }" ]]; then
          # Running for Mag (note the sort -r)
          echo "Beginning Magnitude-Phase fieldmap conversion..."

          magDir=`find $particRawDir -maxdepth 2 -iname "*field*" -print | sort -r | tail -1`
          if [ ! -d $particDir/fieldmaps ]; then
            mkdir -p $particDir/fieldmaps
          fi
          echo "Running dcm2nii for Mag fieldmaps"
          dcm2niix -f "$partic"_Mag -o $particDir/fieldmaps "$magDir"

          magCheckString=`find $particRawDir -maxdepth 2 -iname "*field*" -print | sort | tail -1`
          if [ "$magDir" = "$magCheckString" ]; then
            echo "Only one fieldmap was found. Verify files."
          else
            # Running same system for Phase
            phaseDir=`find $particRawDir -maxdepth 2 -iname "*field*" -print | sort | tail -1`
            echo "Running dcm2nii for Phase fieldmaps"
            dcm2niix -f "$partic"_Phase -o $particDir/fieldmaps "$phaseDir"
          fi
        else
          echo "No Magnitude or Phase fieldmaps found for $partic"
        fi
      else
        echo "Magnitude or Phase fieldmaps are not taken for $study"
      fi
      if [ $dtiBool -eq 1 ]; then
        dtiCheckString=`find $particRawDir -maxdepth 2 -iname "*dti*" -print | sort | tail -1`
        if [[ ! -z "${dtiCheckString// }" ]]; then
          # Running for DTI A -> P (note the sort -r)
          echo "Beginning DTI conversion..."

          dtiAPDir=`find $particRawDir -maxdepth 2 -iname "*dti*" -print | sort -r | tail -1`
          if [ ! -d $particDir/dti ]; then
            mkdir -p $particDir/dti
          fi
          echo "Running dcm2nii for DTI A -> P"
          dcm2niix -f "$partic"_A2P -o $particDir/dti "$dtiAPDir"

          # Running same system for DTI P -> A
          dtiPADir=`find $particRawDir -maxdepth 2 -iname "*P-?A*" -print | sort | tail -1`
          if [ "$dtiPADir" == "x$dtiPADir" ]; then
            echo "P->A file not found, searching P__A"
            dtiPADir=`find $particRawDir -maxdepth 2 -iname "*P_?A*" -print | sort | tail -1`
            if [ "$dtiPADir" == "x$dtiPADir" ]; then
              echo "P__A file not found, searching bzero identifier"
              dtiPADir=`find $particRawDir -maxdepth 2 -iname "*bzero*" -print | sort | tail -1`
            fi
          fi
          if [ "$dtiAPDir" == "$dtiPADir" ]; then
            echo "A -> P and P -> A mismatch for $partic, verify folders exist."
          else
            echo "Running dcm2nii for DTI P -> A"
            dcm2niix -f "$partic"_P2A -o $particDir/dti "$dtiPADir"
          fi
          bval=`find $particDir/dti -maxdepth 2 -iname "*bval*" -print | sort | tail -1`
          bvec=`find $particDir/dti -maxdepth 2 -iname "*bvec*" -print | sort | tail -1`
          mv $bval $particDir/dti/bvals
          mv $bvec $particDir/dti/bvecs
        else
          echo "No DTI images found for $partic"
        fi
      else
        echo "DTI images are not taken for $study"
      fi
      echo "-----------------------------------------------"
      echo "Finished transfer and conversion for $partic"
      echo "-----------------------------------------------"
    fi
  fi
done

echo "Finished all participants."
